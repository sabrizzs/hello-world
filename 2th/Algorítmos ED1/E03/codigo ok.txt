/******************************************************************************
 *
 * MAC0121 ALGORITMOS E ESTRUTURAS DE DADOS I
 * Aluno: Sabrina Araújo da Silva
 * Numero USP: 12566182
 * Tarefa: E03
 * Data: 12/09
 *
 * Baseado em AnimatedHanoi.java, Algoritmo de Frame-Stewart
 *
 * DECLARO QUE SOU O ÚNICO AUTOR E RESPONSÁVEL POR ESTE PROGRAMA.  TODAS AS
 * PARTES DO PROGRAMA, EXCETO AS QUE SÃO BASEADAS EM MATERIAL FORNECIDO
 * PELO PROFESSOR OU COPIADAS DO LIVRO OU DAS BIBLIOTECAS DE SEDGEWICK & WAYNE,
 * FORAM DESENVOLVIDAS POR MIM.  DECLARO TAMBÉM QUE SOU RESPONSÁVEL POR TODAS
 * AS CÓPIAS DESTE PROGRAMA E QUE NÃO DISTRIBUÍ NEM FACILITEI A DISTRIBUIÇÃO
 * DE CÓPIAS DESTA PROGRAMA.
 *
 * javac-introcs Hanoi4.java
 * java-introcs Hanoi4 N
 ******************************************************************************/

public class Hanoi4 {


    //transfere o disco do topo
    private static void topDisc(int nDiscos, int origem, int intermed1, int destino, int intermed2) {
        int k = (int) (nDiscos - Math.round(Math.sqrt(2 * nDiscos + 1)) + 1); //fórmula de k do algoritmo de Frame-Steward

        if (k == 0) {
            StdOut.print(1 + " " + destino + "  ");
            return;
        }
        topDisc(k, origem, destino, intermed1, intermed2);

        hanoi3(nDiscos - k, k, origem, intermed2, destino);

        topDisc(k, intermed1, origem, destino, intermed2);
    }

    //transfere os discos entre 3 torres
    private static void hanoi3(int nDiscos, int k, int origem, int intermed1, int destino) {
        if (nDiscos == 0) return;

        hanoi3(nDiscos - 1, k, origem, destino, intermed1);

        StdOut.print((nDiscos + k) + " " + destino + "  ");

        hanoi3(nDiscos - 1, k, intermed1, origem, destino);
    }

    public static int n(int N) {
        int n = 0, b = 0;
        while (b < N) {
            b += n;
            n++;
        }
        return n - 1;
    }

    public static boolean special(int N) {
        int n = n(N);
        return N == (n + 1) * n / 2;
    }

    public static int f(int n) {
        return (n - 1) * (1 << n) + 1;
    }

    public static void main(String[] args) {
        int nDiscos = Integer.parseInt(args[0]);

        if (special(nDiscos) && args.length > 1) {
            if (f(n(nDiscos)) == 1) {
                StdOut.println(f(n(nDiscos)) + " move");
            } else {
                StdOut.println(f(n(nDiscos)) + " moves");
            }
        }
        topDisc(nDiscos, 0, 2, 1, 3);

    }
}

/******************************************************************************
 *  Compilation:  javac-introcs Hanoi4.java
 *  Execution:    java-introcs Hanoi4 N
 ******************************************************************************/

public class HanoiVelho {

    public static void Hanoi(int N) {
        int[] pole = new int[N + 1];       // pole[i] = pole (0-2) that disc i is on
        Hanoi(N, 0, 2, 3, 1, pole);
    }

    public static void Hanoi(int nDiscos, int origem, int intermed1, int intermed2, int destino, int[] pole) {
        int moves = 0;

        //origem = 0, intermed1 = 1, intermed2 = 2, origem = 3

        if (nDiscos == 1) {
            //System.out.print("Disco " + nDiscos + " de " + origem + "--->" + destino + " ");
            System.out.print(nDiscos + " " + destino + "  ");

        } else if (nDiscos == 2) {

            //System.out.print("Disco " + nDiscos + " de " + origem + "--->" + intermed1 + " ");
            System.out.print((nDiscos - 1) + " " + intermed1 + "  ");
            //System.out.print("Disco " + (nDiscos - 1) + " de " + origem + "--->" + destino + " ");
            System.out.print(nDiscos + " " + destino + "  ");
            //System.out.print("Disco " + nDiscos + " de " + intermed1 + "--->" + destino + " ");
            System.out.print((nDiscos - 1) + " " + destino + "  ");


        } else {

            Hanoi(nDiscos - 2, origem, intermed2, destino, intermed1, pole);

            //System.out.print("Disco " + (nDiscos - 1) + " de " + origem + "--->" + intermed2 + " ");
            System.out.print((nDiscos - 1) + " " + intermed2 + "  ");
            //System.out.print("Disco " + nDiscos + " de " + origem + "--->" + destino + " ");
            System.out.print(nDiscos + " " + destino + "  ");
            //System.out.print("Disco " + (nDiscos - 1) + " de " + intermed2 + "--->" + destino + " ");
            System.out.print((nDiscos - 1) + " " + destino + "  ");

            //StdOut.println("Move disc " + nDiscos + " from pole " + origem + " to pole " + destino);
            //pole[nDiscos] = destino;

            Hanoi(nDiscos - 2, intermed1, origem, intermed2, destino, pole);
        }

    }

    public static void main(String[] args) {
        int nDiscos = Integer.parseInt(args[0]);

        //for (int i = 1; i <= nDiscos; i++)
        //origem[i - 1] = i;
        Hanoi(nDiscos);
    }
}

/******************************************************************************
 *
 * MAC0121 ALGORITMOS E ESTRUTURAS DE DADOS I
 * Aluno: Sabrina Araújo da Silva
 * Numero USP: 12566182
 * Tarefa: E03
 * Data: 12/09
 *
 * Baseado em AnimatedHanoi.java, Algoritmo de Frame-Stewart
 *
 * DECLARO QUE SOU O ÚNICO AUTOR E RESPONSÁVEL POR ESTE PROGRAMA.  TODAS AS
 * PARTES DO PROGRAMA, EXCETO AS QUE SÃO BASEADAS EM MATERIAL FORNECIDO
 * PELO PROFESSOR OU COPIADAS DO LIVRO OU DAS BIBLIOTECAS DE SEDGEWICK & WAYNE,
 * FORAM DESENVOLVIDAS POR MIM.  DECLARO TAMBÉM QUE SOU RESPONSÁVEL POR TODAS
 * AS CÓPIAS DESTE PROGRAMA E QUE NÃO DISTRIBUÍ NEM FACILITEI A DISTRIBUIÇÃO
 * DE CÓPIAS DESTA PROGRAMA.
 *
 * javac-introcs Hanoi4.java
 * java-introcs Hanoi4 N
 ******************************************************************************/

public class Hanoi4 {


    //transfere o disco do topo
    private static String[] topDisc(int nDiscos, int origem, int intermed1, int destino, int intermed2, String[] moves) {
        int k = (int) (nDiscos - Math.round(Math.sqrt(2 * nDiscos + 1)) + 1); //fórmula de k do algoritmo de Frame-Steward

        if (k == 0) {

            for (int i = 0; i < moves.length; i++) {
                if (moves[i] == null) {
                    moves[i] = 1 + " " + destino + "  ";
                    return moves;
                }
            }

            return moves;
        }
        topDisc(k, origem, destino, intermed1, intermed2, moves);

        hanoi3(nDiscos - k, k, origem, intermed2, destino, moves);

        topDisc(k, intermed1, origem, destino, intermed2, moves);

        return moves;
    }

    //transfere os discos entre 3 torres
    private static String[] hanoi3(int nDiscos, int k, int origem, int intermed1, int destino, String[] moves) {
        if (nDiscos == 0) return moves;

        hanoi3(nDiscos - 1, k, origem, destino, intermed1, moves);


        for (int i = 0; i < moves.length; i++) {
            if (moves[i] == null) {
                moves[i] = (nDiscos + k) + " " + destino + "  ";
                break;
            }
        }

        hanoi3(nDiscos - 1, k, intermed1, origem, destino, moves);

        return moves;
    }

    public static int n(int N) {
        int n = 0, b = 0;
        while (b < N) {
            b += n;
            n++;
        }
        return n - 1;
    }

    public static int f(int n) {
        return (n - 1) * (1 << n) + 1;
    }

    public static void main(String[] args) {
        int nDiscos = Integer.parseInt(args[0]);


        String[] moves = new String[f(n(nDiscos))];

        String[] moves1 = topDisc(nDiscos, 0, 2, 1, 3, moves);

        int moves2 = 0;
        for (int i = 0; i < moves1.length; i++) {
            if (moves1[i] != null)
                moves2 += 1;
        }

        if (args.length > 1) {
            if (f(n(nDiscos)) == 1) {
                StdOut.println(moves2 + " move");
            } else {
                StdOut.println(moves2 + " moves");
            }
        }

        for (int i = 0; i < moves1.length; i++) {
            if (moves1[i] != null)
                System.out.printf(moves1[i]);
        }
    }
}


