/****************************************************************************** * * MAC0121 ALGORITMOS E ESTRUTURAS DE DADOS I * Aluno: Sabrina Araújo da Silva * Numero USP: 12566182 * Tarefa: E12 * Data: 28/11 * * Baseado em Quick3way.java. * * DECLARO QUE SOU O UNICO AUTOR E RESPONSAVEL POR ESTE PROGRAMA.  TODAS AS * PARTES DO PROGRAMA, EXCETO AS QUE SÃO BASEADAS EM MATERIAL FORNECIDO * PELO PROFESSOR OU COPIADAS DO LIVRO OU DAS BIBLIOTECAS DE SEDGEWICK & WAYNE, * FORAM DESENVOLVIDAS POR MIM.  DECLARO TAMBÉM QUE SOU RESPONSAVEL POR TODAS * AS COPIAS DESTE PROGRAMA E QUE NAO DISTRIBUI NEM FACILITEI A DISTRIBUICAO * DE CÓPIAS DESTA PROGRAMA. * ******************************************************************************/import edu.princeton.cs.algs4.StdIn;import edu.princeton.cs.algs4.StdOut;public class Anagrams {    public static void sort(String[] a) {        sortSW(a, 0, a.length - 1);    }    // sort com SignedWord    private static void sortSW(String[] a, int lo, int hi) {        if (hi <= lo) return;        int lt = lo, gt = hi;        SignedWord sw0 = new SignedWord(a[lo]);        int i = lo + 1;        while (i <= gt) {            SignedWord sw1 = new SignedWord(a[i]);            int cmp = sw1.compareTo(sw0);            if (cmp < 0) exch(a, lt++, i++);            else if (cmp > 0) exch(a, i, gt--);            else i++;        }        sortSW(a, lo, lt - 1);        sortSW(a, gt + 1, hi);    }    // sort com .words()    private static void sortW(String[] a, int lo, int hi) {        if (hi <= lo) return;        int lt = lo, gt = hi;        String v = a[lo];        int i = lo + 1;        while (i <= gt) {            int cmp = a[i].compareTo(v);            if (cmp < 0) exch(a, lt++, i++);            else if (cmp > 0) exch(a, i, gt--);            else i++;        }        sortW(a, lo, lt - 1);        sortW(a, gt + 1, hi);    }    // v < w ?    private static boolean less(String v, String w) {        return v.compareTo(w) < 0;    }    private static void exch(Object[] a, int i, int j) {        Object swap = a[i];        a[i] = a[j];        a[j] = swap;    }    // coloca queues em um queue de queues    private static void queue(String[] a, int lo, int hi, Queue<Queue<String>> queueQueue) {        Queue<String> queue = new Queue<String>();        for (int i = lo; i < hi + 1; i++) {            queue.enqueue(a[i]);        }        queueQueue.enqueue(queue);    }    // ordena anagramas do array    private static void orderParts(String[] arr, Queue<Queue<String>> queueQueue) {        int lo = 0;        for (int i = 0; i < arr.length; i++) {            SignedWord loSW = new SignedWord(arr[lo]);            SignedWord iSW = new SignedWord(arr[i]);            if (loSW.compareTo(iSW) != 0) {                sortW(arr, lo, i - 1);                queue(arr, lo, i - 1, queueQueue);                lo = i;            }            if (loSW.compareTo(iSW) == 0 && i + 1 == arr.length) {                sortW(arr, lo, i);                queue(arr, lo, i, queueQueue);            }        }    }    // imprime k ou mais anagramas    private static void show(int[] index, Queue<String>[] arrayQ, int k) {        for (int i : index) {            if (arrayQ[i].size() >= k) {                StdOut.print("+");                for (String m : arrayQ[i])                    StdOut.print(" " + m);                StdOut.print("\n");            }        }    }    public static void main(String[] args) {        String[] arr = StdIn.readAllStrings();        int k = 2;        if (args.length == 1) k = Integer.valueOf(args[0]);        sort(arr);        Queue<Queue<String>> queueQueue = new Queue<Queue<String>>();        orderParts(arr, queueQueue);        // transforma a fila de filas em um array de filas        int n = queueQueue.size();        Queue<String>[] arrayQ = (Queue<String>[]) new Queue[n];        String[] arrayQS = new String[n];        int j = 0;        for (Queue<String> i : queueQueue) {            String first = i.peek();            arrayQS[j] = first;            arrayQ[j] = i;            j++;        }        // ordena índices do array de filas em ordem alfabética        int[] index = Merge.indexSort(arrayQS);        show(index, arrayQ, k);    }}